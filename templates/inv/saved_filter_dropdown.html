<select id="savedFiltersSelect" class="form-select form-select-sm">
  <option value="" selected>Select a saved filter</option>
  {% if items %}
    {% for it in items %}
      <option value="{{ it.qs }}">{{ it.name }}</option>
    {% endfor %}
  {% endif %}
</select>

<script>
(function() {
  const sel = document.getElementById('savedFiltersSelect');
  if (!sel) return;

  // Campos del FilterSet (names reales en el form)
  const FILTER_FIELDS = ["type", "assigned_bench", "supplier", "status", "storage_location"];

  // Limpia un input/select (soporta checkbox/radio/múltiple)
  function clearInput(el) {
    if (!el) return;
    if (el.tagName === 'SELECT') {
      if (el.multiple) {
        [...el.options].forEach(opt => opt.selected = false);
      } else {
        el.value = ""; // selecciona "All" (empty_label) en tus ModelChoiceFilter
      }
    } else if (el.type === 'checkbox' || el.type === 'radio') {
      el.checked = false;
    } else {
      el.value = "";
    }
    el.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // Setea un input/select con lista de valores (maneja simple y múltiple)
  function setInput(el, values) {
    if (!el) return;
    if (!Array.isArray(values)) values = [values];

    if (el.tagName === 'SELECT') {
      if (el.multiple) {
        [...el.options].forEach(opt => opt.selected = values.includes(opt.value));
      } else {
        el.value = values[0] ?? "";
      }
    } else if (el.type === 'checkbox' || el.type === 'radio') {
      // Para checkboxes/radios con mismo name:
      // se maneja fuera (con querySelectorAll), aquí no solemos llegar.
      el.checked = values.includes(el.value);
    } else {
      el.value = values[0] ?? "";
    }
    el.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // Aplica el saved filter al #filterForm limpiando lo que no venga en params
  function applySavedFilterToForm(qs) {
    const form = document.getElementById('filterForm');
    if (!form) return;

    const params = new URLSearchParams(qs.startsWith('?') ? qs.slice(1) : qs);
    const presentKeys = new Set(Array.from(params.keys())); // claves que SÍ vinieron

    // 1) Limpiar los campos que NO vengan en params
    FILTER_FIELDS.forEach((name) => {
      if (!presentKeys.has(name)) {
        // puede haber 1 o varios inputs con el mismo name
        const inputs = form.querySelectorAll(`[name="${name}"]`);
        inputs.forEach(clearInput);
      }
    });

    // 2) Aplicar los que SÍ vienen, soportando múltiples valores
    for (const name of presentKeys) {
      const inputs = form.querySelectorAll(`[name="${name}"]`);
      if (inputs.length === 0) continue;

      const values = params.getAll(name); // respeta 'a=1&a=2'
      if (inputs.length > 1) {
        // checkboxes/radios con mismo name
        // limpia primero por si acaso
        inputs.forEach(el => { if (el.type === 'checkbox' || el.type === 'radio') el.checked = false; });
        inputs.forEach(el => {
          if (el.type === 'checkbox' || el.type === 'radio') {
            el.checked = values.includes(el.value);
            el.dispatchEvent(new Event('change', { bubbles: true }));
          } else {
            setInput(el, values);
          }
        });
      } else {
        setInput(inputs[0], values);
      }
    }
  }

  sel.addEventListener('change', function() {
    const qs = sel.value;
    if (!qs) return;
    applySavedFilterToForm(qs);
    // NO enviamos aquí: el usuario pulsará "Show results"
  });
})();
</script>
